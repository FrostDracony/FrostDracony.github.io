{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to FrostWiki! Thanks for visiting the site! I am the creator of it, FrostDracony, and you can find here some tutorials of Slime Rancher modding. Click above on Slime Rancher to read the tutorials that are there. Links Slime Rancher modding tutorials - Click here to access the Slime Rancher modding tutorials","title":"Welcome to FrostWiki!"},{"location":"#welcome-to-frostwiki","text":"Thanks for visiting the site! I am the creator of it, FrostDracony, and you can find here some tutorials of Slime Rancher modding. Click above on Slime Rancher to read the tutorials that are there.","title":"Welcome to FrostWiki!"},{"location":"#links","text":"Slime Rancher modding tutorials - Click here to access the Slime Rancher modding tutorials","title":"Links"},{"location":"SlimeRancher/introduction/","text":"Introduction First of all, the most important thing to know is that we're going to be using SRML to mod the game. I don't really learnt UMF and don't have intentions to do so, because in my opinion SRML is good enough. Here you will find some tutorials about modding Slime Rancher: Chapter 1 - The basics Getting started Making a crate vaccable Introduction to Enums Patching","title":"Introduction"},{"location":"SlimeRancher/introduction/#introduction","text":"First of all, the most important thing to know is that we're going to be using SRML to mod the game. I don't really learnt UMF and don't have intentions to do so, because in my opinion SRML is good enough. Here you will find some tutorials about modding Slime Rancher:","title":"Introduction"},{"location":"SlimeRancher/introduction/#chapter-1-the-basics","text":"Getting started Making a crate vaccable Introduction to Enums Patching","title":"Chapter 1 - The basics"},{"location":"SlimeRancher/tutorials/cratevacc/","text":"Creating vaccable crates Slime Rancher is a really complicated game to mod, so we will start with something that's simple: We all know that we can't collect crates, they stick on the vacuum gun and you can shoot them... but what if we can vacuum them? And that's what we are going to do! Definitions Here are the explanations of some words: Identifiable.Id The creator explained it on the github of SRML. Ammo Ammo is the same as Inventory. Vaccumable/to vacuum Collectable/to collect LookupDirector The creator explained it on the github of SRML. PediaDirector The creator explained it on the github of SRML. How to start Time to insert this code snippet in the Load or PostLoad function in our main class, you can choice where to put. AmmoRegistry.RegisterAmmoPrefab(PlayerState.AmmoMode.DEFAULT, SRSingleton<GameContext>.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01)); Sprite icon = SRSingleton<SceneContext>.Instance.PediaDirector.entries.First((PediaDirector.IdEntry x) => x.id == PediaDirector.Id.ORNAMENTS).icon; LookupRegistry.RegisterVacEntry(Identifiable.Id.CRATE_PARTY_01, new Color32(138, 87, 40, 255), icon); SRSingleton<GameContext>.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01).GetComponent<Vacuumable>().size = Vacuumable.Size.NORMAL; Don\u2018t think I\u2018ll let you simply copy paste my code tho, it\u2018s time to explain what it does! First Line AmmoRegistry.RegisterAmmoPrefab(PlayerState.AmmoMode.DEFAULT, SRSingleton<GameContext>.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01)); Now, lets start with the method AmmoRegistry.RegisterAmmoPrefab : We are making the crate vaccumable. This method accept 2 parameters: An AmmoMode Enum The target GameObject There only exist 2 AmmoMode: DEFAULT (Normal) NIMBLE_VALLEY (Once you pass the gate of Mochi, the item will disappear) For this tutorial we want the DEFAULT (Normal) Enum. Then, we need a GameObject , that means just an object of the game. We want to get the party crate object for this example. SRSingleton<GameContext>.Instance.LookupDirector We are getting the GameContext(SRSingleton<GameContext>.Instance) to then get the LookupDirector . The LookupDirector contains a GetPrefab method, wich requires a Identifiable.Id and returns the desired GameObject . TL;DR (the second parameter) We are getting the GameObject of our Crate. Second Line Sprite icon = SRSingleton<SceneContext>.Instance.PediaDirector.entries.First((PediaDirector.IdEntry x) => x.id == PediaDirector.Id.ORNAMENTS).icon; All collectable objects of the game have their own picture, so why not our? And that's what we are doing! Sprite icon = SRSingleton<SceneContext>.Instance.PediaDirector Like with the LookupDirector , we are getting the PediaDirector from the SceneContext. PediaDirector.entries are all the icons/images of the game. entries.First((PediaDirector.IdEntry x) => x.id == PediaDirector.Id.ORNAMENTS).icon means that we are targeting the Ornaments (These christmas-looking balls), getting an icon from some sort of object. You can change the PediaDirector.Id to the object that you want to have the image Third Line LookupRegistry.RegisterVacEntry(Identifiable.Id.CRATE_PARTY_01, new Color32(138, 87, 40, 255), icon); Here we are assigning some background color and our icon to our crate. LookupRegistry.RegisterVacEntry requires 3 parameters: * The Identifiable.Id of the object that we want to give the colour and icon * The Colour that we want to give * The Icon that we want to give We already have the Id and the Icon, but for the colour you will have to use a rgb sequence. You can go to this website; play around with the settings until you found your colour. Then just copy the number at the red (default 47), then green (default 50) and blue (default 159) slide and put them into the parameters of the new Color32() . So it would be new Color32(47, 50, 159, 255) (first red, then green and finally blue: This order has to be correct!). The last parameter, the 255, is needed for the transparency: You don't will need it. Fourth Line SRSingleton<GameContext>.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01).GetComponent<Vacuumable>().size = Vacuumable.Size.NORMAL; Here we are making the crate actually vaccumable. Remember, in the first line we only made it \"storagable\", so that it can enter the inventory, but if you would run your mod then the crate still will stick on the gun and not enter. SRSingleton<GameContext>.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01) , this has been already seen on the first line, we are getting the GameObject of our crate. .GetComponent<Vacuumable>().size = Vacuumable.Size.NORMAL; Now we are getting the \"Vacuumable Component\" (Think this like a folder), then changing the size property to Vacuumable.Size.NORMAL . We have 3 type of sizes: * NORMAL * LARGE * GIANT Normal is the normal size. This means it can be collected. Large means that it will stick on the vacuum gun (like a normal crate) Giant means that it can't be collected at all, like a gordo. Fifth/Last Line TranslationPatcher.AddActorTranslation(\"l.crate_party_01\", \"Party Crate\"); You can leave it, but this will add the little \"Party Crate\" name in your inventory when you are storing a party crate. We are doing this because crates aren't vacuumable, so there dosen't exist any name that should show up when you have one crate in your inventory. So we have to add one ourself! Conclusion This is a long tutorial, but only because I tried to explain everything in details. This is really confusing at start, but you will get the point. Anyways, the next tutorial part is to add custom slimes (warning, it's a really long part), so enjoy your new crate! P.S. But FrostDracony, where can I find a party crate? I don't want to search the entire map for one! Ok, keep calm: Just spawn one! On Windwos, you can press Ctrl + Tab to access the command bar. Type in spawn CRATE_PARTY_01 and a party crate should spawn where you were looking at! (If it doesn't spawn, then it probably spawned below the map.. Just find a flat place like the ranch and retry the command)","title":"Creating vaccable crates"},{"location":"SlimeRancher/tutorials/cratevacc/#creating-vaccable-crates","text":"Slime Rancher is a really complicated game to mod, so we will start with something that's simple: We all know that we can't collect crates, they stick on the vacuum gun and you can shoot them... but what if we can vacuum them? And that's what we are going to do!","title":"Creating vaccable crates"},{"location":"SlimeRancher/tutorials/cratevacc/#definitions","text":"Here are the explanations of some words: Identifiable.Id The creator explained it on the github of SRML. Ammo Ammo is the same as Inventory. Vaccumable/to vacuum Collectable/to collect LookupDirector The creator explained it on the github of SRML. PediaDirector The creator explained it on the github of SRML.","title":"Definitions"},{"location":"SlimeRancher/tutorials/cratevacc/#how-to-start","text":"Time to insert this code snippet in the Load or PostLoad function in our main class, you can choice where to put. AmmoRegistry.RegisterAmmoPrefab(PlayerState.AmmoMode.DEFAULT, SRSingleton<GameContext>.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01)); Sprite icon = SRSingleton<SceneContext>.Instance.PediaDirector.entries.First((PediaDirector.IdEntry x) => x.id == PediaDirector.Id.ORNAMENTS).icon; LookupRegistry.RegisterVacEntry(Identifiable.Id.CRATE_PARTY_01, new Color32(138, 87, 40, 255), icon); SRSingleton<GameContext>.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01).GetComponent<Vacuumable>().size = Vacuumable.Size.NORMAL; Don\u2018t think I\u2018ll let you simply copy paste my code tho, it\u2018s time to explain what it does!","title":"How to start"},{"location":"SlimeRancher/tutorials/cratevacc/#first-line","text":"AmmoRegistry.RegisterAmmoPrefab(PlayerState.AmmoMode.DEFAULT, SRSingleton<GameContext>.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01)); Now, lets start with the method AmmoRegistry.RegisterAmmoPrefab : We are making the crate vaccumable. This method accept 2 parameters: An AmmoMode Enum The target GameObject There only exist 2 AmmoMode: DEFAULT (Normal) NIMBLE_VALLEY (Once you pass the gate of Mochi, the item will disappear) For this tutorial we want the DEFAULT (Normal) Enum. Then, we need a GameObject , that means just an object of the game. We want to get the party crate object for this example. SRSingleton<GameContext>.Instance.LookupDirector We are getting the GameContext(SRSingleton<GameContext>.Instance) to then get the LookupDirector . The LookupDirector contains a GetPrefab method, wich requires a Identifiable.Id and returns the desired GameObject . TL;DR (the second parameter) We are getting the GameObject of our Crate.","title":"First Line"},{"location":"SlimeRancher/tutorials/cratevacc/#second-line","text":"Sprite icon = SRSingleton<SceneContext>.Instance.PediaDirector.entries.First((PediaDirector.IdEntry x) => x.id == PediaDirector.Id.ORNAMENTS).icon; All collectable objects of the game have their own picture, so why not our? And that's what we are doing! Sprite icon = SRSingleton<SceneContext>.Instance.PediaDirector Like with the LookupDirector , we are getting the PediaDirector from the SceneContext. PediaDirector.entries are all the icons/images of the game. entries.First((PediaDirector.IdEntry x) => x.id == PediaDirector.Id.ORNAMENTS).icon means that we are targeting the Ornaments (These christmas-looking balls), getting an icon from some sort of object. You can change the PediaDirector.Id to the object that you want to have the image","title":"Second Line"},{"location":"SlimeRancher/tutorials/cratevacc/#third-line","text":"LookupRegistry.RegisterVacEntry(Identifiable.Id.CRATE_PARTY_01, new Color32(138, 87, 40, 255), icon); Here we are assigning some background color and our icon to our crate. LookupRegistry.RegisterVacEntry requires 3 parameters: * The Identifiable.Id of the object that we want to give the colour and icon * The Colour that we want to give * The Icon that we want to give We already have the Id and the Icon, but for the colour you will have to use a rgb sequence. You can go to this website; play around with the settings until you found your colour. Then just copy the number at the red (default 47), then green (default 50) and blue (default 159) slide and put them into the parameters of the new Color32() . So it would be new Color32(47, 50, 159, 255) (first red, then green and finally blue: This order has to be correct!). The last parameter, the 255, is needed for the transparency: You don't will need it.","title":"Third Line"},{"location":"SlimeRancher/tutorials/cratevacc/#fourth-line","text":"SRSingleton<GameContext>.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01).GetComponent<Vacuumable>().size = Vacuumable.Size.NORMAL; Here we are making the crate actually vaccumable. Remember, in the first line we only made it \"storagable\", so that it can enter the inventory, but if you would run your mod then the crate still will stick on the gun and not enter. SRSingleton<GameContext>.Instance.LookupDirector.GetPrefab(Identifiable.Id.CRATE_PARTY_01) , this has been already seen on the first line, we are getting the GameObject of our crate. .GetComponent<Vacuumable>().size = Vacuumable.Size.NORMAL; Now we are getting the \"Vacuumable Component\" (Think this like a folder), then changing the size property to Vacuumable.Size.NORMAL . We have 3 type of sizes: * NORMAL * LARGE * GIANT Normal is the normal size. This means it can be collected. Large means that it will stick on the vacuum gun (like a normal crate) Giant means that it can't be collected at all, like a gordo.","title":"Fourth Line"},{"location":"SlimeRancher/tutorials/cratevacc/#fifthlast-line","text":"TranslationPatcher.AddActorTranslation(\"l.crate_party_01\", \"Party Crate\"); You can leave it, but this will add the little \"Party Crate\" name in your inventory when you are storing a party crate. We are doing this because crates aren't vacuumable, so there dosen't exist any name that should show up when you have one crate in your inventory. So we have to add one ourself!","title":"Fifth/Last Line"},{"location":"SlimeRancher/tutorials/cratevacc/#conclusion","text":"This is a long tutorial, but only because I tried to explain everything in details. This is really confusing at start, but you will get the point. Anyways, the next tutorial part is to add custom slimes (warning, it's a really long part), so enjoy your new crate! P.S. But FrostDracony, where can I find a party crate? I don't want to search the entire map for one! Ok, keep calm: Just spawn one! On Windwos, you can press Ctrl + Tab to access the command bar. Type in spawn CRATE_PARTY_01 and a party crate should spawn where you were looking at! (If it doesn't spawn, then it probably spawned below the map.. Just find a flat place like the ranch and retry the command)","title":"Conclusion"},{"location":"SlimeRancher/tutorials/enums/","text":"Enum Patching Little explanation Now, what are ids? Id stands for identifier, the most used enum type would be Identifiable.Id . Why do we need that? Now, very much simplifeid, as the name already implies it itself, think of ids as a way to distinguish things from each other, for example, an hen would have a different Identifiable.Id than a Pink Slime, it's like the object's \"family names\" basically. Now, of course, the ids for our future custom objects don't exist yet, hence why this tutorial in first place! Manual Now, there are two ways at registering our enums, the first one is what I call \"manual\" and the second \"automatic\", we're starting with what I refer to \"manual\". To add new values to enums (for example, our popular Identifiable.Id one, we can use a static class called EnumPatcher inside the main SRML namespace. However, be aware, there are some enums that can only be registered using some Registry classes instead of the EnumPatcher . To add a new value to an enum with EnumPatcher , we use EnumPatcher.AddEnumValue(Type enumType, object value, string name) . Automatic In this method,SRML provides us with an easy method for this, it's an attribute called EnumHolder in the SRML.Utils.Enum namespace. Simply attach this attribute to a static class and when your mod is loaded, SRML will then proceed to register and assign all readonly static fields with the first available free value in that enum. Basically: [EnumHolder] public static class ModdedIds { public static readonly Identifiable.Id CUSTOM_IDENTIFIABLE; // Creating a new Identifiable.id, the first value in Identifiable.Id has the name CUSTOM_IDENTIFIABLE public static readonly Gadget.Id TEST_GADGET; // Even tho it's another type of id, in this case for gadgets, it works the same way as the example above! } Conclusion When should we use the one method and the other, what are the differences of between? Basically, this takes some setup, but it's going to pay off in the long ride. It's way easier and comfortable than the manual method. However, since the manual method doesn't requires classes and etc, it's way more flexible (you can create codes in between the lines incase you're counting to use them just once), however requires more work. For the beginning, just consider the automatic!","title":"Enum Patching"},{"location":"SlimeRancher/tutorials/enums/#enum-patching","text":"","title":"Enum Patching"},{"location":"SlimeRancher/tutorials/enums/#little-explanation","text":"Now, what are ids? Id stands for identifier, the most used enum type would be Identifiable.Id . Why do we need that? Now, very much simplifeid, as the name already implies it itself, think of ids as a way to distinguish things from each other, for example, an hen would have a different Identifiable.Id than a Pink Slime, it's like the object's \"family names\" basically. Now, of course, the ids for our future custom objects don't exist yet, hence why this tutorial in first place!","title":"Little explanation"},{"location":"SlimeRancher/tutorials/enums/#manual","text":"Now, there are two ways at registering our enums, the first one is what I call \"manual\" and the second \"automatic\", we're starting with what I refer to \"manual\". To add new values to enums (for example, our popular Identifiable.Id one, we can use a static class called EnumPatcher inside the main SRML namespace. However, be aware, there are some enums that can only be registered using some Registry classes instead of the EnumPatcher . To add a new value to an enum with EnumPatcher , we use EnumPatcher.AddEnumValue(Type enumType, object value, string name) .","title":"Manual"},{"location":"SlimeRancher/tutorials/enums/#automatic","text":"In this method,SRML provides us with an easy method for this, it's an attribute called EnumHolder in the SRML.Utils.Enum namespace. Simply attach this attribute to a static class and when your mod is loaded, SRML will then proceed to register and assign all readonly static fields with the first available free value in that enum. Basically: [EnumHolder] public static class ModdedIds { public static readonly Identifiable.Id CUSTOM_IDENTIFIABLE; // Creating a new Identifiable.id, the first value in Identifiable.Id has the name CUSTOM_IDENTIFIABLE public static readonly Gadget.Id TEST_GADGET; // Even tho it's another type of id, in this case for gadgets, it works the same way as the example above! }","title":"Automatic"},{"location":"SlimeRancher/tutorials/enums/#conclusion","text":"When should we use the one method and the other, what are the differences of between? Basically, this takes some setup, but it's going to pay off in the long ride. It's way easier and comfortable than the manual method. However, since the manual method doesn't requires classes and etc, it's way more flexible (you can create codes in between the lines incase you're counting to use them just once), however requires more work. For the beginning, just consider the automatic!","title":"Conclusion"},{"location":"SlimeRancher/tutorials/getting_started/","text":"Getting Started Requisites Visual Studio Basic knowledge of C# Having SRML already installed In the case you havent downloaded Visual Studio, you should follow this wonderful tutorial (choose the community option, that\u2018s the free one) For learning basic knowledge of C#, you can look at this excellent playlist from Brackeys . If you won\u2018t have the requisites, don\u2018t expect me explaining it to you. To get SRML, go on it\u2018s NexusMods\u2018 page and follow the instructions there. You can also follow some tutorials on youtube about it. Honorable Mentions mikel veesus heir: many images that I don\u2018t write below \u201ecredited by X\u201c are from mikel\u2018s own wiki. Also of course his SRML, without it, we would need other ways to mod. MrPurple/CabbageCrow: for the assembly publicizer (I think I should mention the creator of the program) Introduction Now, let\u2018s gather up some energy, because this first tutorial will be a long and a bit complicated one. We\u2018re going to install a lot of stuff, so no codding at this point. Also, because I only have Windows, this is a tutorial for Windows users (yet). Because First step: Let\u2018s start a project! Setting up the project I assume you\u2018ve already installed Visual Studio (read the requisites) then set up a project in there. Now, you can use any other IDE if you have one, like JetBrain\u2018s Rider IDE, but VisualStudio is the only one I know that\u2018s free and can do what we need for modding. (So yea, this whole tutorial is basically about visual studio). How to set up a new project in Visual Studio After finally installing VisualStudio, together with C#, we now need to start a project! Select a .NET Framework Class Library for C# Project. (Credits to veesus mikel heir for the image__) After clicking to Next , we\u2018ll land to the Configure your new Project , page. (Credits to veesus mikel heir for the image__) Here, we can set our: project\u2018s name (pretty self-explanatory) the location (only touch it if you want to have the project on a special folder, else leave this setting) the solution\u2018s name (the [NAME_OF_MOD].dll file you download and use for playing the mods, here it\u2018s the name of that .dll file) You can change the project\u2018s name and the solution\u2018s name, but I suggest you to only use this first mod to follow the content of this tutorial series. I\u2018m saying this so that you can concentrate about knowing the structure of a mod, before starting your private one, but feel free to do what you want, it\u2018s only a suggestion. Anyways for this tutorial we\u2018re using the name \u201eMyFirstMod\u201c for the Project and Solution. Adding the needed references Mentions: Because I can\u2018t take screenshots on my laptop, I\u2018m going to instead use the pictures of veesus (this is all WIP so I dont think I\u2018m actually going to show this to anyone, but if anyone sees this, atleast you\u2018re warned about screenshots not matching what I wrote until now). After that, we need to setup the references we need in order to allow us to even start modding (and we make sure to use the publicized assemblies of SRML and Assembly-C). In the solution explorer on the right side of the screen there\u2018s an option called References. After right clicking on this option, click the Add Reference... button Once getting on this menu, select the Browse... option in the bottom right corner (Credits to veesus mikel heir for the images__) The .dll references needed are located in the <slime rancher game folder>/SlimeRancher_Data/Managed folders as well as in <slime rancher game folder>/SRML/Libs , those include the: Assembly-CSharp_old.dll (NOT Assembly-CSharp-firstpass.dll or Assembly-CSharp.dll), SRML.dll, 0Harmony.dll and any UnityEngine .dll files you'll need for your mod (We'll start with UnityEngine.CoreModule.dll for now). (Credits to veesus mikel heir for the images__) See those .dll files? Those are the ones you want to use MrPurple\u2018s AssemblyPublicizer on. Use the AssemblyPublicizer and select the new .dll files, once done that click the Add button near the under right corner and you have your references! The Main.cs , modinfo.json files and Build events Time to set up the Main.cs , modinfo.json files and to add the build events. The Main.cs is going to be the mod\u2018s entry point, the modinfo.json is going to be the file that allows SRML to recognize your mod as a mod and we can use build events to speed up our working. More in details later on. Building the .dll Lets start by build events. Everytime we\u2018re done codding our mod, we usually need to manually take the MyFirstMod.dll generated in [YourRepository]/bin/Debug (the name depends of what you\u2018ve chosen at the beginning, you\u2018ll find the SolutionsName.dll file there, in our case we\u2018ve written MyFirstMod ). First, we need to know 2 different paths: the path of your MyFirstMod.dll and the path of your Mods folder. To get the first path, first you should build your project (do that every time you want to update your builded .dll file). To do that, click on the Build tab at the top of the screen, then select Build Solution . If done correctly, and your code generates no error at building time, you should see Build Succeeded at the bottom of your screen. Finally, we can access the created MyFirstMod.dll file, by right clicking on the project, then selecting Open Folder in File Explorer . Now naviguate to /bin/Debug . And there you should find your MyFirstMod.dll file. Now, you can just drag it to your Mods folder. Main.cs Our first mod is almost ready to run! But there are still some steps to do. First we need to create an entry point for the mod to start execution at. SRML provides an abstract class to help us achieve this, it\u2018s called ModEntryPoint in the SRML namespace. Thanks to it, SRML will auto-detect a class extending ModEntryPoint and run the code found in certain methods inside it, those methods are PreLoad, Load, and PostLoad . Important note: You usually should have a class called Class1.cs , we\u2018re going to rename it (F2) to our Main.cs . PreLoad Everything inside Preload will be executed before you enter your game (more about GameContext and SceneContext on a later chapter). What you need to know for now is that the HarmonyInstance.PatchAll(); is needed, if that isn\u2018t present in PreLoad (and it can only be present in Preload), then your whole mod wont probably work. More about HarmonyPatching in later chapters. Also, if we want to register (aka make so that the game can recognise it) an object to the game, or add manually new enum values (the id of your object), then it\u2018s here that happens. If you don\u2018t get it, no worries, everything\u2018s going to be explained with some examples later on. Load Everything inside Load will be executed when the game starts. Here it\u2018s where most of registering stuff happen. For example, we write here when we\u2018re registering a slime, food, or etc. PostLoad Everything inside here will be executed after the game has already loaded. It\u2018s perfect to modify things that already exist in game, like a texture, color, and etc. But it\u2018s not a place to register new things, because at this point, the game has already loaded, and you can\u2018t add new things to the game if it\u2018s already loaded. The ModEntryPoint So, after having explored the 3 functions, now it\u2018s time to see how to use the ModEntryPoint abstract class. using SRML; using System; using System.Collections.Generic; using System.Linq; using System.Text; // Feel free to change the namespace to another name namespace MyFirstMod { public class Main : ModEntryPoint { // Called before GameContext.Awake // You want to register new things and enum values here, as well as do all your harmony patching public override void PreLoad() { HarmonyInstance.PatchAll(); } // Called before GameContext.Start // Used for registering things that require a loaded gamecontext public override void Load() { } // Called after all mods Load's have been called // Used for editing existing assets in the game, not a registry step public override void PostLoad() { } } } modinfo.json Now, the last thing to set up is the modinfo.json file. It\u2018s needed to SRML to recognise the mod at all. First, start by creating an text file, and rename it to modinfo.json . Now, write this in the file (it\u2018s a template, so feel free to copy it): { \"id\": \"myfirstmod\", \"name\": \"My First Mod\", \"author\": \"frostdracony\", \"description\": \"This is the first mod I have ever made!\", \"version\": \"1.0\" } Now, after saving it, select the file in your solution explorer. We can find lots of information about the file at the bottom of the solution explorer, included an option that reads, Build Action . By clicking on it and selecting Embedded Resource . This will make the C# compiler include your modinfo.json in your mods final .dll, thus allowing it to be recognized by SRML. Building and testing Now that we have our Main.cs and modinfo.json files, it's time to build and test your mod! To build a project in visual studio, click on the Build tab at the top of the screen and select Build Solution. If done correctly, and your code generates no error at building time, you should see Build Succeeded at the bottom of your screen. Finally, we can access the created MyFirstMod.dll file, by right clicking on the project, then selecting Open Folder in File Explorer . Now navigate to /bin/Debug . And there you should find your MyFirstMod.dll file. Now, you can just copy-paste it to your Mods folder. Now just start slime rancher and you should see, after clicking the Mods tab , your mod information. If it\u2018s there, then your first mod is ready! Now, for now, your mod isn\u2018t doing anything. Now, after all that setup, we can finally start the fun part about modding in the next tutorials. There are some optional things we can do, but you\u2018re not forced to. Else: I wish you good luck with your modding adventure! Optional Build events (RECOMMENDED) Now, to be honnest, after a while, having to drag your mod DLL everytime to the Mods folder can become tiring. For this, we can automize the proccess of it. Now, instead of dragging the build (aka MyFirstMod.dll ) to the Mods folder, copy it\u2018s path (right click on your MyFirstMod.dll and select Copy as path ) (Example image, credits to the How-To Geek website). After doing this, you can go to the Build Event tab on your Settings (Image from Mitesh Sureja\u2018s Blog ) Now in theh Post-build event command line , add this: xcopy \"(PathToCopyFrom)\" \"(TargetPath)\" Now, replace the \"(PathToCopyFrom)\" with the copy I asked you to copy before, the path to MyFirstMod.dll . You should now add the MyFirstMod.dll at the end of your copied path, so the first half looks like xcopy \"YourPath\\MyFirstMod.dll\" \"(TargetPath)\"\" . Now lets focus on the \"(TargetPath)\" , you just need to locate your Mods folder (the one where you usually add your mods to play modded SlimeRancher), and same as for the MyFirstMod.dll , right click and press Copy as path . Now finally replace the with your copied path, and the first half is done! The command we\u2018ve written in the Post-build event command line will make it easier for us to copy that .dll file into the Mods folder. Now, to make it work, just build the mod and the game should start all by itself! MrPurple\u2018s AssemblyPublicizer Now, I would like to mention that this is a upgraded version of CabbageCrow\u2018s AssemblyPublicizer , but considering it has some issues that will become visible later on, we\u2018re using this upgraded one. Shout to CabbageCrow ! We will have to use MrPurple\u2018s AssemblyPublicizer to allow us to access every property we\u2018re going to need in our modding journey. It allows us to convert a .dll file with lots of private elements (aka properties, variables, functions, etc\u2026) to a copy of it, containing only public elements. In other words: \u201cThings we can\u2018t access become accessible for our code\u201c. It\u2018s like a big house where every door is closed, you have no way to open them by yourself. Now the AssemblyPublicizer comes in game and opens magically for you all the doors! ~~(It actually recreates the house and keeps the doors open, creating a copy of the closed house, but let\u2018s pretend it just opens them by magic)~~ You can download it here . Now, how to use it? It\u2018s written on the github page (so I won\u2018t explain it here) Now, where we use it? Wait for the \u201cAdding the needed references\u201c section Setting \u201eAllow unsafe code\u201c Now, talking for experience (painful hours wasted for this 1 single thing), we\u2018re going to need to set a compiler option, else every time we\u2018re going to build the project it\u2018s going to result into an error. For this we need to set the \u201eallow unsafe code\u201c option to true. There are 2 ways to achieve this, one via the IDE, one via editing the .csproj of the project. 1. For the first way, proceed to open the project's Properties page in your Visual Studio development environment (aka IDE). Click the Build property page, then select the Allow Unsafe Code check box. 2. For the second way, open your .csproj file and add this snippet below: <PropertyGroup> <AllowUnsafeBlocks>true</AllowUnsafeBlocks> </PropertyGroup> (Credit to this StackOverflow post , a bit outdated, but it still works with modern Visual Studio versions) Adding the new references Just remove the old references and add the publicized ones. After all what we\u2018ve done yet, you should be able to access codes you first weren\u2018t able to touch!","title":"Getting Started"},{"location":"SlimeRancher/tutorials/getting_started/#getting-started","text":"","title":"Getting Started"},{"location":"SlimeRancher/tutorials/getting_started/#requisites","text":"Visual Studio Basic knowledge of C# Having SRML already installed In the case you havent downloaded Visual Studio, you should follow this wonderful tutorial (choose the community option, that\u2018s the free one) For learning basic knowledge of C#, you can look at this excellent playlist from Brackeys . If you won\u2018t have the requisites, don\u2018t expect me explaining it to you. To get SRML, go on it\u2018s NexusMods\u2018 page and follow the instructions there. You can also follow some tutorials on youtube about it.","title":"Requisites"},{"location":"SlimeRancher/tutorials/getting_started/#honorable-mentions","text":"mikel veesus heir: many images that I don\u2018t write below \u201ecredited by X\u201c are from mikel\u2018s own wiki. Also of course his SRML, without it, we would need other ways to mod. MrPurple/CabbageCrow: for the assembly publicizer (I think I should mention the creator of the program)","title":"Honorable Mentions"},{"location":"SlimeRancher/tutorials/getting_started/#introduction","text":"Now, let\u2018s gather up some energy, because this first tutorial will be a long and a bit complicated one. We\u2018re going to install a lot of stuff, so no codding at this point. Also, because I only have Windows, this is a tutorial for Windows users (yet). Because First step: Let\u2018s start a project!","title":"Introduction"},{"location":"SlimeRancher/tutorials/getting_started/#setting-up-the-project","text":"I assume you\u2018ve already installed Visual Studio (read the requisites) then set up a project in there. Now, you can use any other IDE if you have one, like JetBrain\u2018s Rider IDE, but VisualStudio is the only one I know that\u2018s free and can do what we need for modding. (So yea, this whole tutorial is basically about visual studio).","title":"Setting up the project"},{"location":"SlimeRancher/tutorials/getting_started/#how-to-set-up-a-new-project-in-visual-studio","text":"After finally installing VisualStudio, together with C#, we now need to start a project! Select a .NET Framework Class Library for C# Project. (Credits to veesus mikel heir for the image__) After clicking to Next , we\u2018ll land to the Configure your new Project , page. (Credits to veesus mikel heir for the image__) Here, we can set our: project\u2018s name (pretty self-explanatory) the location (only touch it if you want to have the project on a special folder, else leave this setting) the solution\u2018s name (the [NAME_OF_MOD].dll file you download and use for playing the mods, here it\u2018s the name of that .dll file) You can change the project\u2018s name and the solution\u2018s name, but I suggest you to only use this first mod to follow the content of this tutorial series. I\u2018m saying this so that you can concentrate about knowing the structure of a mod, before starting your private one, but feel free to do what you want, it\u2018s only a suggestion. Anyways for this tutorial we\u2018re using the name \u201eMyFirstMod\u201c for the Project and Solution.","title":"How to set up a new project in Visual Studio"},{"location":"SlimeRancher/tutorials/getting_started/#adding-the-needed-references","text":"Mentions: Because I can\u2018t take screenshots on my laptop, I\u2018m going to instead use the pictures of veesus (this is all WIP so I dont think I\u2018m actually going to show this to anyone, but if anyone sees this, atleast you\u2018re warned about screenshots not matching what I wrote until now). After that, we need to setup the references we need in order to allow us to even start modding (and we make sure to use the publicized assemblies of SRML and Assembly-C). In the solution explorer on the right side of the screen there\u2018s an option called References. After right clicking on this option, click the Add Reference... button Once getting on this menu, select the Browse... option in the bottom right corner (Credits to veesus mikel heir for the images__) The .dll references needed are located in the <slime rancher game folder>/SlimeRancher_Data/Managed folders as well as in <slime rancher game folder>/SRML/Libs , those include the: Assembly-CSharp_old.dll (NOT Assembly-CSharp-firstpass.dll or Assembly-CSharp.dll), SRML.dll, 0Harmony.dll and any UnityEngine .dll files you'll need for your mod (We'll start with UnityEngine.CoreModule.dll for now). (Credits to veesus mikel heir for the images__) See those .dll files? Those are the ones you want to use MrPurple\u2018s AssemblyPublicizer on. Use the AssemblyPublicizer and select the new .dll files, once done that click the Add button near the under right corner and you have your references!","title":"Adding the needed references"},{"location":"SlimeRancher/tutorials/getting_started/#the-maincs-modinfojson-files-and-build-events","text":"Time to set up the Main.cs , modinfo.json files and to add the build events. The Main.cs is going to be the mod\u2018s entry point, the modinfo.json is going to be the file that allows SRML to recognize your mod as a mod and we can use build events to speed up our working. More in details later on.","title":"The Main.cs, modinfo.json files and Build events"},{"location":"SlimeRancher/tutorials/getting_started/#building-the-dll","text":"Lets start by build events. Everytime we\u2018re done codding our mod, we usually need to manually take the MyFirstMod.dll generated in [YourRepository]/bin/Debug (the name depends of what you\u2018ve chosen at the beginning, you\u2018ll find the SolutionsName.dll file there, in our case we\u2018ve written MyFirstMod ). First, we need to know 2 different paths: the path of your MyFirstMod.dll and the path of your Mods folder. To get the first path, first you should build your project (do that every time you want to update your builded .dll file). To do that, click on the Build tab at the top of the screen, then select Build Solution . If done correctly, and your code generates no error at building time, you should see Build Succeeded at the bottom of your screen. Finally, we can access the created MyFirstMod.dll file, by right clicking on the project, then selecting Open Folder in File Explorer . Now naviguate to /bin/Debug . And there you should find your MyFirstMod.dll file. Now, you can just drag it to your Mods folder.","title":"Building the .dll"},{"location":"SlimeRancher/tutorials/getting_started/#maincs","text":"Our first mod is almost ready to run! But there are still some steps to do. First we need to create an entry point for the mod to start execution at. SRML provides an abstract class to help us achieve this, it\u2018s called ModEntryPoint in the SRML namespace. Thanks to it, SRML will auto-detect a class extending ModEntryPoint and run the code found in certain methods inside it, those methods are PreLoad, Load, and PostLoad . Important note: You usually should have a class called Class1.cs , we\u2018re going to rename it (F2) to our Main.cs .","title":"Main.cs"},{"location":"SlimeRancher/tutorials/getting_started/#preload","text":"Everything inside Preload will be executed before you enter your game (more about GameContext and SceneContext on a later chapter). What you need to know for now is that the HarmonyInstance.PatchAll(); is needed, if that isn\u2018t present in PreLoad (and it can only be present in Preload), then your whole mod wont probably work. More about HarmonyPatching in later chapters. Also, if we want to register (aka make so that the game can recognise it) an object to the game, or add manually new enum values (the id of your object), then it\u2018s here that happens. If you don\u2018t get it, no worries, everything\u2018s going to be explained with some examples later on.","title":"PreLoad"},{"location":"SlimeRancher/tutorials/getting_started/#load","text":"Everything inside Load will be executed when the game starts. Here it\u2018s where most of registering stuff happen. For example, we write here when we\u2018re registering a slime, food, or etc.","title":"Load"},{"location":"SlimeRancher/tutorials/getting_started/#postload","text":"Everything inside here will be executed after the game has already loaded. It\u2018s perfect to modify things that already exist in game, like a texture, color, and etc. But it\u2018s not a place to register new things, because at this point, the game has already loaded, and you can\u2018t add new things to the game if it\u2018s already loaded.","title":"PostLoad"},{"location":"SlimeRancher/tutorials/getting_started/#the-modentrypoint","text":"So, after having explored the 3 functions, now it\u2018s time to see how to use the ModEntryPoint abstract class. using SRML; using System; using System.Collections.Generic; using System.Linq; using System.Text; // Feel free to change the namespace to another name namespace MyFirstMod { public class Main : ModEntryPoint { // Called before GameContext.Awake // You want to register new things and enum values here, as well as do all your harmony patching public override void PreLoad() { HarmonyInstance.PatchAll(); } // Called before GameContext.Start // Used for registering things that require a loaded gamecontext public override void Load() { } // Called after all mods Load's have been called // Used for editing existing assets in the game, not a registry step public override void PostLoad() { } } }","title":"The ModEntryPoint"},{"location":"SlimeRancher/tutorials/getting_started/#modinfojson","text":"Now, the last thing to set up is the modinfo.json file. It\u2018s needed to SRML to recognise the mod at all. First, start by creating an text file, and rename it to modinfo.json . Now, write this in the file (it\u2018s a template, so feel free to copy it): { \"id\": \"myfirstmod\", \"name\": \"My First Mod\", \"author\": \"frostdracony\", \"description\": \"This is the first mod I have ever made!\", \"version\": \"1.0\" } Now, after saving it, select the file in your solution explorer. We can find lots of information about the file at the bottom of the solution explorer, included an option that reads, Build Action . By clicking on it and selecting Embedded Resource . This will make the C# compiler include your modinfo.json in your mods final .dll, thus allowing it to be recognized by SRML.","title":"modinfo.json"},{"location":"SlimeRancher/tutorials/getting_started/#building-and-testing","text":"Now that we have our Main.cs and modinfo.json files, it's time to build and test your mod! To build a project in visual studio, click on the Build tab at the top of the screen and select Build Solution. If done correctly, and your code generates no error at building time, you should see Build Succeeded at the bottom of your screen. Finally, we can access the created MyFirstMod.dll file, by right clicking on the project, then selecting Open Folder in File Explorer . Now navigate to /bin/Debug . And there you should find your MyFirstMod.dll file. Now, you can just copy-paste it to your Mods folder. Now just start slime rancher and you should see, after clicking the Mods tab , your mod information. If it\u2018s there, then your first mod is ready! Now, for now, your mod isn\u2018t doing anything. Now, after all that setup, we can finally start the fun part about modding in the next tutorials. There are some optional things we can do, but you\u2018re not forced to. Else: I wish you good luck with your modding adventure!","title":"Building and testing"},{"location":"SlimeRancher/tutorials/getting_started/#optional","text":"","title":"Optional"},{"location":"SlimeRancher/tutorials/getting_started/#build-events-recommended","text":"Now, to be honnest, after a while, having to drag your mod DLL everytime to the Mods folder can become tiring. For this, we can automize the proccess of it. Now, instead of dragging the build (aka MyFirstMod.dll ) to the Mods folder, copy it\u2018s path (right click on your MyFirstMod.dll and select Copy as path ) (Example image, credits to the How-To Geek website). After doing this, you can go to the Build Event tab on your Settings (Image from Mitesh Sureja\u2018s Blog ) Now in theh Post-build event command line , add this: xcopy \"(PathToCopyFrom)\" \"(TargetPath)\" Now, replace the \"(PathToCopyFrom)\" with the copy I asked you to copy before, the path to MyFirstMod.dll . You should now add the MyFirstMod.dll at the end of your copied path, so the first half looks like xcopy \"YourPath\\MyFirstMod.dll\" \"(TargetPath)\"\" . Now lets focus on the \"(TargetPath)\" , you just need to locate your Mods folder (the one where you usually add your mods to play modded SlimeRancher), and same as for the MyFirstMod.dll , right click and press Copy as path . Now finally replace the with your copied path, and the first half is done! The command we\u2018ve written in the Post-build event command line will make it easier for us to copy that .dll file into the Mods folder. Now, to make it work, just build the mod and the game should start all by itself!","title":"Build events (RECOMMENDED)"},{"location":"SlimeRancher/tutorials/getting_started/#mrpurples-assemblypublicizer","text":"Now, I would like to mention that this is a upgraded version of CabbageCrow\u2018s AssemblyPublicizer , but considering it has some issues that will become visible later on, we\u2018re using this upgraded one. Shout to CabbageCrow ! We will have to use MrPurple\u2018s AssemblyPublicizer to allow us to access every property we\u2018re going to need in our modding journey. It allows us to convert a .dll file with lots of private elements (aka properties, variables, functions, etc\u2026) to a copy of it, containing only public elements. In other words: \u201cThings we can\u2018t access become accessible for our code\u201c. It\u2018s like a big house where every door is closed, you have no way to open them by yourself. Now the AssemblyPublicizer comes in game and opens magically for you all the doors! ~~(It actually recreates the house and keeps the doors open, creating a copy of the closed house, but let\u2018s pretend it just opens them by magic)~~ You can download it here . Now, how to use it? It\u2018s written on the github page (so I won\u2018t explain it here) Now, where we use it? Wait for the \u201cAdding the needed references\u201c section","title":"MrPurple\u2018s AssemblyPublicizer"},{"location":"SlimeRancher/tutorials/getting_started/#setting-allow-unsafe-code","text":"Now, talking for experience (painful hours wasted for this 1 single thing), we\u2018re going to need to set a compiler option, else every time we\u2018re going to build the project it\u2018s going to result into an error. For this we need to set the \u201eallow unsafe code\u201c option to true. There are 2 ways to achieve this, one via the IDE, one via editing the .csproj of the project. 1. For the first way, proceed to open the project's Properties page in your Visual Studio development environment (aka IDE). Click the Build property page, then select the Allow Unsafe Code check box. 2. For the second way, open your .csproj file and add this snippet below: <PropertyGroup> <AllowUnsafeBlocks>true</AllowUnsafeBlocks> </PropertyGroup> (Credit to this StackOverflow post , a bit outdated, but it still works with modern Visual Studio versions)","title":"Setting \u201eAllow unsafe code\u201c"},{"location":"SlimeRancher/tutorials/getting_started/#adding-the-new-references","text":"Just remove the old references and add the publicized ones. After all what we\u2018ve done yet, you should be able to access codes you first weren\u2018t able to touch!","title":"Adding the new references"}]}